<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Partial Lenses Validation</title>
    <link rel="icon" href="https://avatars1.githubusercontent.com/u/17234211">
    <link rel="stylesheet" type="text/css" href="fw/github.css">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/googlecode.min.css">
    <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
    <link rel="stylesheet" type="text/css" href="fw/styles.css">
    <script type="text/javascript">startTime = Date.now()</script>
    <script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-52808982-2','auto');ga('send','pageview');</script>
  </head>
  <body class="markdown-body">
    <div class="loading-message">
      Please wait... The interactive code snippets on this page take a moment to render.
    </div>
    <div class="menu">
      <div class="menu-overlay"></div>
      <div class="menu-body">
        <div class="menu-side">
          <div>≡</div>
          <a id="to-top" href="#" onclick="">▲</a>
        </div>
        <div class="menu-contents"></div>
      </div>
    </div>
    <p>
      All the code snippets on this page are <b>live</b> and <b>interactive</b>
      powered by the <a target="_blank" href="https://github.com/viebel/klipse">klipse
      plugin</a>.
    </p>
    <hr>
    <h1><a id="partial-lenses-validation"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#">■</a> <a href="#partial-lenses-validation">Partial Lenses Validation</a> &middot; <a href="https://gitter.im/calmm-js/chat"><img src="https://img.shields.io/gitter/room/calmm-js/chat.js.svg" alt="Gitter"></a> <a href="https://github.com/calmm-js/partial.lenses.validation"><img src="https://img.shields.io/github/stars/calmm-js/partial.lenses.validation.svg?style=social" alt="GitHub stars"></a> <a href="https://www.npmjs.com/package/partial.lenses.validation"><img src="https://img.shields.io/npm/dm/partial.lenses.validation.svg" alt="npm"></a></h1>
<p>This is a library of validation
<a href="https://github.com/calmm-js/partial.lenses/#transforms">transform</a>
<a href="https://wiki.haskell.org/Combinator">combinators</a>.  The main idea is to produce
validation errors in the same shape as the data structure being validated.  This
way validation errors can be accessed at the same path as the data and can be
mechanically associated with the corresponding elements of the validated data
structure.</p>
<p><a href="http://badge.fury.io/js/partial.lenses.validation"><img src="https://badge.fury.io/js/partial.lenses.validation.svg" alt="npm version"></a>
<a href="https://badge.fury.io/bo/partial.lenses.validation"><img src="https://badge.fury.io/bo/partial.lenses.validation.svg" alt="Bower version"></a>
<a href="https://travis-ci.org/calmm-js/partial.lenses.validation"><img src="https://travis-ci.org/calmm-js/partial.lenses.validation.svg?branch=master" alt="Build Status"></a>
<a href="https://codecov.io/github/calmm-js/partial.lenses.validation?branch=master"><img src="https://img.shields.io/codecov/c/github/calmm-js/partial.lenses.validation/master.svg" alt="Code Coverage"></a>
<a href="https://david-dm.org/calmm-js/partial.lenses.validation"><img src="https://david-dm.org/calmm-js/partial.lenses.validation.svg" alt=""></a>
<a href="https://david-dm.org/calmm-js/partial.lenses.validation?type=dev"><img src="https://david-dm.org/calmm-js/partial.lenses.validation/dev-status.svg" alt=""></a></p>
<h2><a id="contents"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#contents">■</a> <a href="#contents">Contents</a></h2>
<ul>
<li><a href="#an-example">An example</a></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#elimination">Elimination</a><ul>
<li><a href="#synchronous">Synchronous</a><ul>
<li><a href="#V-accepts"><code>V.accepts(rule, data) ~&gt; boolean</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-errors"><code>V.errors(rule, data) ~&gt; errors | undefined</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-validate"><code>V.validate(rule, data) ~{throws}~&gt; data</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#asynchronous">Asynchronous</a><ul>
<li><a href="#V-acceptsAsync"><code>V.acceptsAsync(rule, data) ~&gt; promise(boolean)</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-errorsAsync"><code>V.errorsAsync(rule, data) ~&gt; promise(errors | undefined)</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-validateAsync"><code>V.validateAsync(rule, data) ~&gt; promise(data)</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-tryValidateAsyncNow"><code>V.tryValidateAsyncNow(rule, data) ~{throws}~&gt; data | promise(data)</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#general">General</a><ul>
<li><a href="#V-run"><code>V.run({Monad, onAccept: data =&gt; any, onReject: error =&gt; any}, rule, data) ~&gt; any</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
</ul>
</li>
<li><a href="#primitive">Primitive</a><ul>
<li><a href="#V-accept"><code>V.accept ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-acceptAs"><code>V.acceptAs(value) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-acceptWith"><code>V.acceptWith((value, index) =&gt; value) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-reject"><code>V.reject ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-rejectAs"><code>V.rejectAs(error) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-rejectWith"><code>V.rejectWith((value, index) =&gt; error) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-remove"><code>V.remove ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#elaboration">Elaboration</a><ul>
<li><a href="#V-modifyError"><code>V.modifyError((value, error, index) =&gt; error, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-setError"><code>V.setError(error, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#predicates">Predicates</a><ul>
<li><a href="#V-where"><code>V.where((value, index) =&gt; testable) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#logical">Logical</a><ul>
<li><a href="#V-and"><code>V.and(...rules) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-not"><code>V.not(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-or"><code>V.or(...rules) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#arrays">Arrays</a><ul>
<li><a href="#V-args"><code>V.args(...rules) ~&gt; rule</code></a> <small><sup>v0.3.1</sup></small></li>
<li><a href="#V-arrayId"><code>V.arrayId(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-arrayIx"><code>V.arrayIx(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-tuple"><code>V.tuple(...rules) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#functions">Functions</a><ul>
<li><a href="#V-dependentFn"><code>V.dependentFn(rule, (...args) =&gt; rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-freeFn"><code>V.freeFn(rule, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#objects">Objects</a><ul>
<li><a href="#V-keep"><code>V.keep(&#39;prop&#39;, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-optional"><code>V.optional(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-props"><code>V.props({...prop: rule}) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-propsOr"><code>V.propsOr(rule, {...prop: rule}) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#conditional">Conditional</a><ul>
<li><a href="#V-cases"><code>V.cases(...[(value, index) =&gt; testable, rule][, [rule]]) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
<li><a href="#V-ifElse"><code>V.ifElse((value, index) =&gt; testable, rule, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#dependent">Dependent</a><ul>
<li><a href="#V-choose"><code>V.choose((value, index) =&gt; rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
<li><a href="#recursive">Recursive</a><ul>
<li><a href="#V-lazy"><code>V.lazy(rule =&gt; rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></li>
</ul>
</li>
</ul>
</li>
<li><a href="#known-caveats">Known caveats</a></li>
<li><a href="#related-work">Related work</a></li>
</ul>
<h2><a id="an-example"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#an-example">■</a> <a href="#an-example">An example</a></h2>
<p>Imagine a UI, or take a look at this <a href="https://codesandbox.io/s/x20w218owo">live
example</a>, for editing a data structure that
is an array (table) of objects (records) that have a <code>date</code> field and an <code>event</code>
field:</p>
<pre><code class="hljs lang-json">[
  {&quot;date&quot;: &quot;2017-09-11&quot;, &quot;event&quot;: &quot;EFSA-H&quot;},
  {&quot;date&quot;: &quot;2017-09-20&quot;, &quot;event&quot;: &quot;EFSA-T&quot;},
  {&quot;date&quot;: &quot;&quot;,           &quot;event&quot;: &quot;EFSA-T&quot;}
]
</code></pre>
<p>We need to validate that each object has a valid date and an event and that
dates and events are unique.  Furthermore, we wish to give feedback on all
elements with errors so as to guide the user.</p>
<p>Here is a sample set of rules</p>
<pre><code class="hljs lang-js">var rules = V.choose(events =&gt; V.arrayIx(V.props({
  date: V.and(
    [isNonEmpty,                  &#39;required&#39;],
    [isValidDate,                 &#39;yyyy-mm-dd&#39;],
    [isUniqueBy(&#39;date&#39;, events),  &#39;duplicate&#39;]),
  event: V.and(
    [isNonEmpty,                  &#39;required&#39;],
    [isUniqueBy(&#39;event&#39;, events), &#39;duplicate&#39;])
})))
</code></pre>
<p>where</p>
<pre><code class="hljs lang-js">var isNonEmpty = R.identity

function isUniqueBy(p, xs) {
  const counts = L.counts([L.elems, p], xs)
  return x =&gt; counts.get(x) &lt;= 1
}

var isValidDate = R.test(/^\d{4}-\d{2}-\d{2}$/)
</code></pre>
<p>to give such validation feedback.  The rules basically just follow the structure
of the data.</p>
<p>Validating with those rules we get a data structure with the potential error
feedback at the same location as the offending element:</p>
<pre><code class="hljs lang-js">V.errors(rules, [
  {&quot;date&quot;: &quot;2017-09-11&quot;, &quot;event&quot;: &quot;EFSA-H&quot;},
  {&quot;date&quot;: &quot;2017-09-20&quot;, &quot;event&quot;: &quot;EFSA-T&quot;},
  {&quot;date&quot;: &quot;&quot;,           &quot;event&quot;: &quot;EFSA-T&quot;}
])
</code></pre>
<p>The result tells us that the first object is valid (i.e. there are no validation
errors in it).  The <code>event</code> in the second object is a duplicate.  The third
object is missing a date and the event is a duplicate.</p>
<h2><a id="reference"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#reference">■</a> <a href="#reference">Reference</a></h2>
<p>The <a href="https://wiki.haskell.org/Combinator">combinators</a> provided by this library
are available as named imports.  Typically one just imports the library as:</p>
<pre><code class="hljs lang-jsx">import * as V from &#39;partial.lenses.validation&#39;
</code></pre>
<p>This library is actually built on top of <a href="https://github.com/calmm-js/partial.lenses/">Partial
Lenses</a>
<a href="https://github.com/calmm-js/partial.lenses#transforms">transforms</a>.  It is also
typical to use e.g. <a href="http://ramdajs.com/">Ramda</a>, bound as <code>R</code> in examples, to
implement predicates.</p>
<h3><a id="elimination"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#elimination">■</a> <a href="#elimination">Elimination</a></h3>
<p>To use a validation rule one runs it using one of the elimination functions.</p>
<h4><a id="synchronous"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#synchronous">■</a> <a href="#synchronous">Synchronous</a></h4>
<p>In case a validation rule is fully synchronous, it is better to use a
synchronous elimination function, because synchronous validation is faster than
asynchronous validation.</p>
<h5><a id="V-accepts"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-accepts">■</a> <a href="#V-accepts"><code>V.accepts(rule, data) ~&gt; boolean</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.accepts(rule, data)</code> runs the given validation rule on the given data and
simply returns <code>true</code> in case the data is accepted and <code>false</code> if not.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.accepts(V.arrayIx(R.is(String)), [&#39;Yes&#39;, &#39;No&#39;])
</code></pre>
<h5><a id="V-errors"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-errors">■</a> <a href="#V-errors"><code>V.errors(rule, data) ~&gt; errors | undefined</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.errors(rule, data)</code> runs the given validation rule on the given data.  In
case the data is accepted by the rule, the result is <code>undefined</code>.  Otherwise the
result is an object structure in the shape of the data structure containing the
validation errors.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.errors(
  V.props({
    no: R.is(Number),
    yes: R.is(String)
  }),
  {
    yes: 101,
  }
)
</code></pre>
<p>Note that in case a validation error would be <code>undefined</code>, a <code>null</code> is reported
instead.</p>
<h5><a id="V-validate"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-validate">■</a> <a href="#V-validate"><code>V.validate(rule, data) ~{throws}~&gt; data</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.validate(rule, data)</code> runs the given validation rule on the given input data.
In case the data is accepted, the validated output data is returned.  In case
the data is rejected, an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error"><code>Error</code>
object</a>
is thrown whose message is the stringified validation error and that has an
extra <code>errors</code> property that has the (non-stringified) validation errors.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.props({
    missing: R.is(String)
  }),
  {
    unexpected: &#39;field&#39;
  }
)
</code></pre>
<h4><a id="asynchronous"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#asynchronous">■</a> <a href="#asynchronous">Asynchronous</a></h4>
<p>In case a validation rule contains asynchronous parts, it is necessary to use
one of the asynchronous elimination functions.  The below <code>ghInfoOfAsync</code>
function is a simple asynchronous function that tries to use the <a href="https://developer.github.com/v3/search/#search-repositories">public GitHub
search API</a> to
search for information on a GitHub project of specified name:</p>
<pre><code class="hljs lang-js">async function ghInfoOfAsync(name) {
  const q = encodeURIComponent(name)
  const res = await fetch(`https://api.github.com/search/repositories?q=${q}`)
  const body = await res.json()
  return L.get([&#39;items&#39;, L.find(R.whereEq({name}))], body)
}
</code></pre>
<h5><a id="V-acceptsAsync"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-acceptsAsync">■</a> <a href="#V-acceptsAsync"><code>V.acceptsAsync(rule, data) ~&gt; promise(boolean)</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.acceptsAsync(rule, data)</code> runs the given validation rule on the given data
like <a href="#V-accepts"><code>V.accepts</code></a> except that the validation rule is allowed to
contain asynchronous validation predicates and transformations.  The result will
always be returned as a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>.</p>
<h5><a id="V-errorsAsync"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-errorsAsync">■</a> <a href="#V-errorsAsync"><code>V.errorsAsync(rule, data) ~&gt; promise(errors | undefined)</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.errorsAsync(rule, data)</code> runs the given validation rule on the given data
like <a href="#V-errors"><code>V.errors</code></a> except that the validation rule is allowed to
contain asynchronous validation predicates and transformations.  The result will
always be returned as a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.errorsAsync(
  V.arrayId(
    R.pipeP(ghInfoOfAsync, L.get(&#39;stargazers_count&#39;), R.lte(100))
  ),
  [
    &#39;partial.lenses&#39;,
    &#39;partial.lenses.validation&#39;
  ]
).catch(R.identity).then(console.log)
</code></pre>
<h5><a id="V-validateAsync"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-validateAsync">■</a> <a href="#V-validateAsync"><code>V.validateAsync(rule, data) ~&gt; promise(data)</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.validateAsync(rule, data)</code> runs the given validation rule on the given data
like <a href="#V-validate"><code>V.validate</code></a> except that the validation rule is allowed to
contain asynchronous validation predicates and transformations.  The result,
whether accepted or rejected, is returned as a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validateAsync(
  V.arrayId(
    V.and(
      R.is(String),
      V.acceptWith(ghInfoOfAsync),
      V.keep(
        &#39;name&#39;,
        V.propsOr(V.remove, {
          name: R.is(String),
          stargazers_count: V.and(
            R.is(Number),
            [R.lte(1000), n =&gt; `Only ${n} stars. You know how to fix it!`]
          )
        })
      )
    )
  ),
  [
    &#39;partial.lenses&#39;,
    &#39;partial.lenses.validation&#39;
  ]
).catch(R.identity).then(console.log)
</code></pre>
<h5><a id="V-tryValidateAsyncNow"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-tryValidateAsyncNow">■</a> <a href="#V-tryValidateAsyncNow"><code>V.tryValidateAsyncNow(rule, data) ~{throws}~&gt; data | promise(data)</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.tryValidateAsyncNow(rule, data)</code> runs the given validation rule on the give
data like <a href="#V-validateAsync"><code>V.validateAsync</code></a> except that in case the
validation result is synchronously available it is returned or thrown
immediately as is without wrapping it inside a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>.
In case the result is not available synchronously, a promise is returned.</p>
<p><code>V.tryValidateAsyncNow</code> can be used for wrapping asynchronous functions, for
example, because the first stage of validating a function is always synchronous.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">var ghInfoOfAsyncChecked = V.tryValidateAsyncNow(
  V.dependentFn(
    V.args(R.and(R.is(String), V.not(R.isEmpty))),
    name =&gt; V.or(
      R.equals(undefined),
      V.propsOr(V.accept, {
        name: R.equals(name),
        stargazers_count: R.is(Number)
        // ...
      })
    )
  ),
  ghInfoOfAsync
)
</code></pre>
<p>You can now replace calls to <code>ghInfoOfAsync</code> in the previous examples to call
the above dynamically checked version <code>ghInfoOfAsyncChecked</code>.</p>
<h4><a id="general"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#general">■</a> <a href="#general">General</a></h4>
<p>It is also possible to run validation rules with an arbitrary computational
monad such as a monad based on observables.</p>
<h5><a id="V-run"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-run">■</a> <a href="#V-run"><code>V.run({Monad, onAccept: data =&gt; any, onReject: error =&gt; any}, rule, data) ~&gt; any</code></a> <small><sup>v0.3.0</sup></small></h5>
<p><code>V.run({Monad, onAccept, onReject}, rule, data)</code> runs the given validation rule
on the given data using the specified computational monad and either calls the
accept callback with the validated data or the reject callback with the
validation errors.</p>
<p>The parameters <code>Monad</code>, <code>onAccept</code>, and <code>onReject</code> are optional and default to
what <a href="#V-validate"><code>V.validate</code></a> uses.  The <code>Monad</code> parameter needs to be a
<a href="https://github.com/rpominov/static-land">Static Land</a> compatible
<a href="https://github.com/rpominov/static-land">Monad</a> with all the four functions.
If you specify the <code>Monad</code>, you will likely want to specify both <code>onAccept</code> and
<code>onReject</code> as well.</p>
<h3><a id="primitive"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#primitive">■</a> <a href="#primitive">Primitive</a></h3>
<p>At the most basic level a rule either accepts or rejects the value in focus.</p>
<h4><a id="V-accept"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-accept">■</a> <a href="#V-accept"><code>V.accept ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.accept</code> accepts the current focus as is.  <code>V.accept</code> should be rarely used as
it performs no validation whatsoever.</p>
<h4><a id="V-acceptAs"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-acceptAs">■</a> <a href="#V-acceptAs"><code>V.acceptAs(value) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.acceptAs(value)</code> accepts the current focus and replaces it with the given
value.  <code>V.acceptAs</code> is rarely used alone and is usually combined <code>V.acceptAs</code>
with e.g. <a href="#V-and"><code>V.and</code></a>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(V.and(R.equals(1), V.acceptAs(&#39;one&#39;)), 1)
</code></pre>
<h4><a id="V-acceptWith"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-acceptWith">■</a> <a href="#V-acceptWith"><code>V.acceptWith((value, index) =&gt; value) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.acceptWith(fn)</code> accepts the current focus and replaces it with the value
returned by the given function.  <code>V.acceptWith</code> is rarely used alone and is
usually combined <code>V.acceptWith</code> with e.g. <a href="#V-and"><code>V.and</code></a>.</p>
<p>In a logical <a href="#V-or"><code>V.or</code></a> each rule gets the same value as input and the
result of the first accepting rule becomes the result.  In a logical
<a href="#V-and"><code>V.and</code></a> the output of a previous rule becomes the input of the next
rule.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.and(
    V.or(
      V.and(
        R.is(Number),
        V.acceptWith(n =&gt; `number ${n}`)
      ),
      R.is(String)
    ),
    V.acceptWith(R.toUpper)
  ),
  10
)
</code></pre>
<h4><a id="V-reject"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-reject">■</a> <a href="#V-reject"><code>V.reject ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.reject</code> rejects the current focus as is.  In case the focus is <code>undefined</code>,
the error will be <code>null</code> instead.</p>
<p>The idea is that the validation error data structure simply contains the parts
of the validated data structure that weren&#39;t accepted.  This usually allows a
programmer who is familiar with the system to quickly diagnose the problem.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.errors(
  V.propsOr(V.reject, {}),
  {
    thisField: &#39;is not allowed&#39;,
  }
)
</code></pre>
<h4><a id="V-rejectAs"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-rejectAs">■</a> <a href="#V-rejectAs"><code>V.rejectAs(error) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.rejectAs(error)</code> rejects the current focus as the given error value.  In case
the given error value is <code>undefined</code>, it is replaced with <code>null</code> instead.</p>
<p>Using <code>V.rejectAs</code> one can specify what the error should be.  This way an error
data structure can be constructed that can, for example, contain error messages
to be displayed in a form that an end user can understand.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.errors(
  V.propsOr(V.rejectAs(&#39;Unexpected field&#39;), {}),
  {
    thisField: &#39;is not allowed&#39;,
  }
)
</code></pre>
<h4><a id="V-rejectWith"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-rejectWith">■</a> <a href="#V-rejectWith"><code>V.rejectWith((value, index) =&gt; error) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.rejectWith(fn)</code> rejects the current focus with the error value returned by
the given function from the value in focus.  In case the return value is
<code>undefined</code>, the error will be <code>null</code> instead.</p>
<p>Using <code>V.rejectWith</code> one can specify what the error should be depending on the
value in focus.  This allows detailed error messages to be constructed.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.errors(
  V.propsOr(
    V.rejectWith(value =&gt; `Unexpected field: ${JSON.stringify(value)}`),
    {}
  ),
  {
    thisField: &#39;is not allowed&#39;,
  }
)
</code></pre>
<h4><a id="V-remove"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-remove">■</a> <a href="#V-remove"><code>V.remove ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.remove</code> replaces the not yet rejected value in focus with <code>undefined</code>,
which means that it is removed from the surrounding array or object.  Beware
that <code>V.remove</code> by itself performs no validation.  You usually combine
<code>V.remove</code> with e.g. <a href="#V-and"><code>V.and</code></a> or <a href="#V-propsOr"><code>V.propsOr</code></a>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.propsOr(V.remove, {
    required: R.is(String)
  }),
  {
    required: &#39;field&#39;,
    unexpected: &#39;and removed&#39;
  }
)
</code></pre>
<h3><a id="elaboration"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#elaboration">■</a> <a href="#elaboration">Elaboration</a></h3>
<p>It is also possible to modify the error after a rule has rejected the focus.</p>
<h4><a id="V-modifyError"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-modifyError">■</a> <a href="#V-modifyError"><code>V.modifyError((value, error, index) =&gt; error, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.modifyError(fn, rule)</code>, or using the shorthand notation <code>[rule, fn]</code>, acts
like <code>rule</code> except that in case the rule rejects the focus, the error is
computed using the given function that is given the value in focus, the error
from the rule and the index of the focus.  In case the given function returns
<code>undefined</code>, the error will be <code>null</code> instead.</p>
<p>Note that the shorthand notation <code>[rule, fn]</code> can be used instead of a more
verbose function call.  This shorthand is provided to make it more convenient to
attach detailed error messages to rules.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.errors(
  V.choose(data =&gt; {
    const expectedSum = L.sum([&#39;numbers&#39;, L.elems], data)
    return V.props({
      numbers: V.arrayIx(R.is(Number)),
      sum: [ // &lt;-- Implicit `V.modifyError`
        R.equals(expectedSum),
        actualSum =&gt; `Expected ${expectedSum} instead of ${actualSum}`
      ]
    })
  }),
  {
    numbers: [3, 1, 4],
    sum: 9
  }
)
</code></pre>
<h4><a id="V-setError"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-setError">■</a> <a href="#V-setError"><code>V.setError(error, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.setError(error, rule)</code>, or using the shorthand notation <code>[rule, error]</code> when
<code>error</code> is not a function, acts like <code>rule</code> except that in case the rule rejects
the focus, the given error is used instead.  In case the given error is
<code>undefined</code>, it is replaced with <code>null</code> instead.</p>
<p>Note that the shorthand notation <code>[rule, error]</code> can be used instead of a more
verbose function call when the <code>error</code> is not a function.  In case <code>error</code> is a
function, it is called like with <a href="#V-modifyError"><code>V.modifyError</code></a>.  This
shorthand is provided to make it more convenient to attach detailed error
messages to rules.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.errors(
  V.choose(data =&gt; {
    const expectedSum = L.sum([&#39;numbers&#39;, L.elems], data)
    return V.props({
      numbers: V.arrayIx(R.is(Number)),
      sum: [ // &lt;-- Implicit `V.setError`
        R.equals(expectedSum),
        `Expected ${expectedSum}`
      ]
    })
  }),
  {
    numbers: [3, 1, 4],
    sum: 9
  }
)
</code></pre>
<h3><a id="predicates"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#predicates">■</a> <a href="#predicates">Predicates</a></h3>
<p>Unary (and binary) functions are implicitly treated as predicates and lifted to
validation rules using <a href="#V-where"><code>V.where</code></a>.</p>
<h4><a id="V-where"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-where">■</a> <a href="#V-where"><code>V.where((value, index) =&gt; testable) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.where(predicate)</code>, or using the shorthand notation <code>predicate</code>, lifts the
given predicate to a validation rule.  In case the focus does not satisfy the
predicate, it is rejected with <a href="#V-reject"><code>V.reject</code></a>.</p>
<p>Note that explicitly calling <code>V.where</code> is typically unnecessary, because unary
(and binary) functions are implicitly treated as predicates and lifted with
<code>V.where</code> to rules in this library.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.props({
    isNumber: V.where(R.is(Number)),
    alsoNumber: R.is(Number) // &lt;-- implicit `V.where`
  }),
  {
    isNumber: 101,
    alsoNumber: 42
  }
)
</code></pre>
<h3><a id="logical"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#logical">■</a> <a href="#logical">Logical</a></h3>
<p>Logical connectives provide a simple means to combine rules to form more complex
rules.</p>
<h4><a id="V-and"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-and">■</a> <a href="#V-and"><code>V.and(...rules) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.and(rule1, ..., ruleN)</code> validates the value in focus with all of the given
rules one-by-one starting from the first given rule.  In case some rule rejects
the focus, that becomes the result of <code>V.and</code>.  Otherwise the result of <code>V.and</code>
is the accepted result produced by passing the original focus through all of the
given rules.</p>
<h4><a id="V-not"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-not">■</a> <a href="#V-not"><code>V.not(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.not(rule)</code> validates the value in focus with the given rule.  In case the
rule accepts the focus, <code>V.not</code> rejects it instead.  In case the rule rejects
the focus, <code>V.not</code> accepts it instead.</p>
<h4><a id="V-or"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-or">■</a> <a href="#V-or"><code>V.or(...rules) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.or(rule1, ..., ruleN)</code> tries to validate the value in focus with one of the
given rules starting from the first given rule.  In case some rule accepts the
focus, that becomes the result of <code>V.or</code>.  Otherwise the error produced by the
last of the given rules becomes the result of <code>V.or</code>.</p>
<h3><a id="arrays"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#arrays">■</a> <a href="#arrays">Arrays</a></h3>
<p>Rules for validating elements can be lifted to rules for validating arrays of
elements.</p>
<h4><a id="V-arrayId"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-arrayId">■</a> <a href="#V-arrayId"><code>V.arrayId(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.arrayId(rule)</code> validates the elements of an array with the given rule.  In
case one or more elements are rejected, the error is an array containing only
the rejected elements.</p>
<p>The idea is that the elements of the validated array are addressed by some
unique identities intrinsic to the elements.  Filtering out the accepted
elements keeps the error result readable.</p>
<h4><a id="V-arrayIx"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-arrayIx">■</a> <a href="#V-arrayIx"><code>V.arrayIx(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.arrayIx(rule)</code> validates the elements of an array with the given rule.  In
case one or more elements are rejected, the error is an array containing the
rejected elements and <code>null</code> values for the accepted elements.</p>
<p>The idea is that elements of the validated array are addressed only by their
index and it is necessary to keep the rejected elements at their original
indices.  The accepted elements are replaced with <code>null</code> to make the output less
noisy.</p>
<h4><a id="V-args"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-args">■</a> <a href="#V-args"><code>V.args(...rules) ~&gt; rule</code></a> <small><sup>v0.3.1</sup></small></h4>
<p><code>V.args(rule1, ..., ruleN)</code> validates an array by validating each element of the
array with a specific rule.  If the array is shorter than the number of rules,
the missing elements are treated as being <code>undefined</code> and validated with the
corresponding rules.  This means that rules for optional elements need to be
explicitly specified as such.  If the array is longer than the number of rules,
the extra elements are simply accepted.  This is roughly how JavaScript treats
function arguments.  See also <a href="#V-tuple"><code>V.tuple</code></a>.</p>
<h4><a id="V-tuple"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-tuple">■</a> <a href="#V-tuple"><code>V.tuple(...rules) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.tuple(rule1, ..., ruleN)</code> validates a fixed length array by validating each
element of the array with a specific rule.  See also <a href="#V-args"><code>V.args</code></a>.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.accepts(
  V.tuple(R.is(String), R.is(Number)),
  [&#39;one&#39;, 2]
)
</code></pre>
<p>Note that elements cannot be removed from a tuple using <a href="#V-remove"><code>V.remove</code></a>.</p>
<h3><a id="functions"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#functions">■</a> <a href="#functions">Functions</a></h3>
<p>It is also possible to validate functions.  Of course, validating a function is
different from validating data, because it is not possible to validate the
actual arguments to a function before the function is called and likewise it is
only possible to validate the return value of a function after the function
returns.  Therefore validating a function means that the function is wrapped
with a function that performs validation of arguments and the return value as
the function is called.</p>
<h4><a id="V-dependentFn"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-dependentFn">■</a> <a href="#V-dependentFn"><code>V.dependentFn(rule, (...args) =&gt; rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.dependentFn(argumentsRule, argumentsToResultRule)</code> <a href="#V-acceptWith">wraps</a> the
function at focus with a validating wrapper that validates the arguments to and
return value from the function as it is called.  The rule for validating the
return value is constructed by calling the given function with the validated
arguments.  In case there is no need for the return value rule to depend on the
actual arguments, one can use the simpler <a href="#V-freeFn"><code>V.freeFn</code></a> combinator
instead.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">var sqrt = V.validate(
  V.dependentFn(
    V.args(R.both(R.is(Number), R.lte(0))),
    x =&gt; y =&gt; Math.abs(y*y - x) &lt; 0.001
  ),
  Math.sqrt
)

sqrt(4)
</code></pre>
<p>Note that the wrapped function produced by <code>V.dependentFn</code> is not curried and
has zero arity.  If necessary, you can wrap the produced function with
e.g. <code>R.curryN</code> or <code>R.nAry</code> to change the arity of the function.</p>
<h4><a id="V-freeFn"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-freeFn">■</a> <a href="#V-freeFn"><code>V.freeFn(rule, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.freeFn(argumentsRule, resultRule)</code> <a href="#V-acceptWith">wraps</a> the function at
focus with a validating wrapper that validates the arguments to and return value
from the function as it is called.  <code>V.freeFn</code> does not allow the rule for the
return value to depend on the arguments.  If you wish to validate the return
value depending on the arguments you need to use the
<a href="#V-dependentFn"><code>V.dependentFn</code></a> combinator.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">var random = V.validate(
  V.freeFn(
    V.tuple(),
    R.both(R.lte(0), R.gt(1))
  ),
  Math.random
)

random(&#39;Does not take arguments!&#39;)
</code></pre>
<p>Note that the wrapped function produced by <code>V.freeFn</code> is not curried and has
zero arity.  If necessary, you can wrap the produced function with
e.g. <code>R.curryN</code> or <code>R.nAry</code> to change the arity of the function.</p>
<h3><a id="objects"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#objects">■</a> <a href="#objects">Objects</a></h3>
<p>Rules for validating objects can be formed by composing rules for validating
individual properties of objects.</p>
<h4><a id="V-keep"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-keep">■</a> <a href="#V-keep"><code>V.keep(&#39;prop&#39;, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.keep(&#39;prop&#39;, rule)</code> acts like the given rule except that in case the rule
rejects the focus, the specified property is copied from the original value to
the error value.  This is useful when e.g. validating arrays of objects with an
identifying property.  Keeping the identifying property allows the rejected
object to be identified.</p>
<h4><a id="V-optional"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-optional">■</a> <a href="#V-optional"><code>V.optional(rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.optional(rule)</code> acts like the given rule except that in case the focus is
<code>undefined</code> it is accepted without invoking the given rule.  This is
particularly designed for specifying that an object property is optional.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.arrayIx(
    V.props({
      field: V.optional([R.is(Number), &#39;Expected a number&#39;])
    })
  ),
  [
    {notTheField: []},
    {field: &#39;Not a number&#39;},
    {field: 76}
  ]
)
</code></pre>
<h4><a id="V-props"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-props">■</a> <a href="#V-props"><code>V.props({...prop: rule}) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.props({prop: rule, ...})</code> is for validating an object and is given a template
object of rules with which to validate the corresponding fields.  Unexpected
fields are rejected.  Note that <code>V.props</code> is equivalent to
<a href="#V-propsOr"><code>V.propsOr(V.reject)</code></a>.</p>
<h4><a id="V-propsOr"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-propsOr">■</a> <a href="#V-propsOr"><code>V.propsOr(rule, {...prop: rule}) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.propsOr(otherwise, {prop: rule, ...})</code> is for validating an object and is
given a rule to apply to fields not otherwise specified and a template object of
rules with which to validate the corresponding fields.  Note that
<a href="#V-props"><code>V.props</code></a> is equivalent to <code>V.propsOr(V.reject)</code>.</p>
<h3><a id="conditional"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#conditional">■</a> <a href="#conditional">Conditional</a></h3>
<p>Rules can be chosen conditionally on the data being validated.</p>
<h4><a id="V-cases"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-cases">■</a> <a href="#V-cases"><code>V.cases(...[(value, index) =&gt; testable, rule][, [rule]]) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.cases([p1, r1], ..., [pN, rN], [r])</code> is given <code>[predicate, rule]</code> -pairs as
arguments.  The predicates are called from first to last with the focus.  In
case a predicate passes, the corresponding rule is used on the focus and the
remaining predicates are skipped and rules ignored.  The last argument to
<code>V.cases</code> can be a default rule that omits the predicate, <code>[rule]</code>, in which
case the rule is always applied in case no predicate passes.  In case all
predicates fail and there is no default rule, the focus is rejected.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.cases(
    [
      R.whereEq({type: &#39;a&#39;}),
      V.propsOr(V.accept, {
        foo: [R.lt(0), &#39;Must be positive&#39;]
      })
    ],
    [
      V.propsOr(V.accept, {
        foo: [R.gt(0), &#39;Must be negative&#39;]
      })
    ]
  ),
  {
    type: &#39;b&#39;,
    foo: 10
  }
)
</code></pre>
<p>Note that, like with <a href="#V-ifElse"><code>V.ifElse</code></a>, <code>V.cases([p1, r1], ..., [rN])</code> can
be expressed in terms of the logical operators, but <code>V.cases</code> has a simpler
internal implementation and is likely to be faster.</p>
<h4><a id="V-ifElse"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-ifElse">■</a> <a href="#V-ifElse"><code>V.ifElse((value, index) =&gt; testable, rule, rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.ifElse(predicate, consequent, alternative)</code> acts like the given consequent
rule in case the predicate is satisfied by the focus and otherwise like the
given alternative rule.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.ifElse(R.is(Number), R.lte(0), R.is(String)),
  -1
)
</code></pre>
<p>Note that <code>V.ifElse(p, c, a)</code> can be expressed as <code>V.or(V.and(p, c),
V.and(V.not(p), a))</code>, but <code>V.ifElse</code> has a simpler internal implementation and
is likely to be faster.</p>
<h3><a id="dependent"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#dependent">■</a> <a href="#dependent">Dependent</a></h3>
<p>Sometimes validation rules need to depend on the data being validated.</p>
<h4><a id="V-choose"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-choose">■</a> <a href="#V-choose"><code>V.choose((value, index) =&gt; rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.choose(fn)</code> is given a function that gets the current focus and then must
return rules to be used on the focus.  This allows rules to depend on the data
and allows rules that examine multiple parts of the data.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.validate(
  V.choose(({a, b}) =&gt; V.props({
    a: [R.equals(b), &quot;Must equal &#39;b&#39;&quot;],
    b: [R.equals(a), &quot;Must equal &#39;a&#39;&quot;]
  })),
  {
    a: 1,
    b: 2
  }
)
</code></pre>
<p>Note that <code>V.choose</code> can be used to implement conditionals like
<a href="#V-cases"><code>V.cases</code></a> and <a href="#V-ifElse"><code>V.ifElse</code></a>.  Also note that code inside
<code>V.choose</code>, including code that constructs rules, is always run when the
<code>V.choose</code> rule itself is used.  For performance reasons it can be advantageous
to move invariant expressions outside of the body of the function given to
<code>V.choose</code>.  Also, when simpler conditional combinators like
<a href="#V-cases"><code>V.cases</code></a> or <a href="#V-ifElse"><code>V.ifElse</code></a> are sufficient, they can be
preferable for performance reasons, because they are given previously
constructed rules.</p>
<h3><a id="recursive"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#recursive">■</a> <a href="#recursive">Recursive</a></h3>
<p>Rules for recursive data structures can be constructed with the help of
<a href="#V-choose"><code>V.choose</code></a> and <a href="#V-lazy"><code>V.lazy</code></a>, which both allow one to refer
back to the rule itself or to delay the invocation of a rule computing function.</p>
<h4><a id="V-lazy"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#V-lazy">■</a> <a href="#V-lazy"><code>V.lazy(rule =&gt; rule) ~&gt; rule</code></a> <small><sup>v0.3.0</sup></small></h4>
<p><code>V.lazy(fn)</code> constructs a rule lazily.  The given function is passed a
forwarding proxy to its own return value.  This allows the rule to use itself as
a subrule and construct a recursive rule.</p>
<p>For example:</p>
<pre><code class="hljs lang-js">V.accepts(
  V.lazy(tree =&gt; V.arrayId(
    V.props({
      name: R.is(String),
      children: tree
    })
  )),
  [
    {
      name: &#39;root&#39;,
      children: [
        {name: &#39;1st child&#39;, children: []},
        {
          name: &#39;2nd child&#39;,
          children: [{name: &#39;You got the point&#39;, children: []}]
        },
      ]
    }
  ]
)
</code></pre>
<h2><a id="known-caveats"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#known-caveats">■</a> <a href="#known-caveats">Known caveats</a></h2>
<p>Probably the main weakness in the design of this library is that this library
specifically tries to avoid having to implement everything.  In particular, one
of the ideas is to simply allow arbitrary predicates from a library like
<a href="http://ramdajs.com/">Ramda</a> to be used as rules.  This means that rules do not
contain extra information such as a corresponding <a href="https://en.wikipedia.org/wiki/QuickCheck">random value
generator</a> of values matching the rule
or a traversable specification of the rule for exporting the specification for
<a href="https://en.wikipedia.org/wiki/OpenAPI_Specification">external tools</a>.  One way
to provide such features is to pair validation rules with the necessary extra
information.  It should be possible to do that outside of this library.</p>
<p>The current implementation does not operate
<a href="https://en.wikipedia.org/wiki/Incremental_computing">incrementally</a>.  Every
time e.g. <a href="#V-validate"><code>V.validate</code></a> is called, everything is recomputed.  This
can become a performance issue particularly in an interactive setting where
small incremental changes to a data structure are being validated in response to
user actions.  It should be possible to implement caching so that on repeated
calls only changes would be recomputed.  This is left for future work.</p>
<h2><a id="related-work"></a> <a href="#contents">≡</a> <a href="https://github.com/calmm-js/partial.lenses.validation/blob/master/README.md#related-work">■</a> <a href="#related-work">Related work</a></h2>
<p>This library primarily exists as a result of Stefan Rimaila&#39;s work on
<a href="https://github.com/stuf/validation">validation</a> using lenses.</p>

    <div class="loading-hidden">
      <pre><code class="hljs lang-js">
        document.querySelector('.loading-message').className = "loading-hidden";
        ga('send', 'event', 'completed', 'load', Math.round((Date.now() - startTime)/1000));
        accelerate_klipse();
      </code></pre>
    </div>
    <script type="text/javascript" src="https://unpkg.com/babel-polyfill/dist/polyfill.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/infestines/dist/infestines.js"></script>
    <script type="text/javascript" src="https://unpkg.com/partial.lenses/dist/partial.lenses.js"></script>
    <script type="text/javascript" src="partial.lenses.validation.js"></script>
    <script type="text/javascript" src="https://unpkg.com/ramda/dist/ramda.min.js"></script>
    <script type="text/javascript" src="fw/klipse-settings.js"></script>
    <script type="text/javascript" src="https://storage.googleapis.com/app.klipse.tech/plugin_prod/js/klipse_plugin.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
    <script type="text/javascript" src="fw/init-hljs.js"></script>
    <script type="text/javascript" src="fw/menu.js"></script>
    <script type="text/javascript" src="fw/tooltips.js"></script>
    <script type="text/javascript" src="fw/clicks-to-ga.js"></script>
  </body>
</html>